<!DOCTYPE html>
<html>

<head>
    <title>SQUINGO</title>
    <meta charset="UTF-8">
</head>

<style>
    body {
        background: #222;
        font-family: monospace;
        color: #ddd;
    }

    .input-so-far {
        background: none;
        border: 0;
        font-family: inherit;
        color: inherit;
        caret-color: inherit;
        user-select: none;
        font-size: inherit;
    }

    .input-so-far:focus {
        outline: none;
    }

    .postprocessing-text {
        padding-top: 1em;
        padding-bottom: 1em;
    }

    .outcome-screen {
        padding-bottom: 1em;
    }

    @keyframes blink {
        50% {
            opacity: 0;
        }
    }

    .outcome-text {
        white-space: pre;
        animation: blink 1s infinite step-start;
    }

    .outcome-text-squingo {
        color: #0f0;
    }

    .outcome-text-not-squingo {
        color: #f00;
    }

    .outcome-text-monkey-pirate {
        color: #f0f;
    }

    .outcome-graphic {
        white-space: pre;
    }
</style>

<body>
    <div id="console"></div>
</body>

<script>
    // possible page titles to set on load

    const PAGE_TITLES = [
        "ð•Šâ„šð•Œð•€â„•ð”¾ð•†",
        "SÌ¸Ì¥ÍŽÌ˜Ì¹ÍÌ“Ì€ÌˆÍ—ÌŒQÌµÌ–Ì’Í†UÌ¶Ì™Í‘Ì½Ì€Í›ÍÃŒÌ·Ì—Ì–Í’NÌ·Ì˜Ì°Ì²Ì®Í‹Ì’Ì½GÌ´Ì–Ì£Ì¥Í‡Í‰Ì‹ÌˆÌÌ•OÌ´ÌÌ¤ÍÌ’Í’",
        "ðŸ†‚ðŸ†€ðŸ†„ðŸ…¸ðŸ…½ðŸ…¶ðŸ…¾",
        "ð“¼ð“ºð“¾ð“²ð“·ð“°ð“¸",
        "ð˜´ð˜²ð˜¶ð˜ªð˜¯ð˜¨ð˜°",
        "oÆƒuá´‰nbs"
    ]

    // probability that each given loading message is the easter egg message
    const LOADING_EASTER_EGG_PROBABILILITY = 0.01

    // easter egg loading text (appears with probability given by EASTER_EGG_Loading_PERCENTAGE)
    const LOADING_EASTER_EGG_TEXT = "SOMEBODY PLEASE HELP ME I AM STUCK IN THE COMPUTER OPEN TH"

    // possible filler texts to use when processing a hand

    const LOADING_MESSAGE_VERBS = [
        "Reticulating",
        "Degaussing",
        "Repiping",
        "Rebooting",
        "Differentiating with respect to",
        "Consuming",
        "Flummoxing",
        "Derezzing",
        "Applying the Fourier transform to",
        "Defibrillating",
        "Sublimating",
        "Arming",
        "Energizing",
        "Aerosolizing",
        "Exterminating",
        "Traversing",
        "Minifying",
        "Compressing",
        "Warming up",
        "Neutralizing",
        "Quantifying",
        "Vectorizing",
        "Rasterizing",
        "Kerning",
        "Parallelizing",
        "Hashing",
        "Encrypting",
        "Decrypting"
    ]

    const LOADING_MESSAGE_NOUNS = [
        "splines",
        "boron wave shift-scoop",
        "plasma",
        "beryllium antigravity turbine bracket",
        "chromium dorsal crystal core",
        "Higgs bosons",
        "dilithium",
        "kyber crystals",
        "energized protodermis",
        "exsidian layer",
        "psionic unit",
        "moon device",
        "REDACTED",
        "adamantium shell",
        "cockroaches",
        "droid brains",
        "hyperdrive",
        "big data",
        "blockchain",
        "Gaussian surface",
        "vector field",
        "flux",
        "ad impressions",
        "social graph",
        "kerning",
        "ligatures",
        "GPUs",
        "graphene nanotubes"
    ]

    // each "frame" of text in the ellipsis animation
    const ELLIPSIS_FRAMES = [
        "",
        ".",
        "..",
        "..."
    ]

    // the length in characters of a full progress bar
    const FULL_PROGRESS_BAR_LENGTH_CHARS = 75

    // how long in milliseconds the progress bar should freeze in the late 90th percentages
    const PROGRESS_BAR_FREEZE_TIME_MS = 5000

    // the possible outcomes of each match
    const Outcome = {
        SQUINGO: "squingo",
        NOT_SQUINGO: "not squingo",
        MONKEY_PIRATE: "monkey pirate",
    }

    // a map from each outcome to its probability relative to the other outcomes
    const OUTCOME_TO_RELATIVE_PROBABILITY = {
        [Outcome.SQUINGO]: 46,
        [Outcome.NOT_SQUINGO]: 44,
        [Outcome.MONKEY_PIRATE]: 10,
    }

    // text to print when the hand is a double payout ("Squingo")
    // (text from https://texteditor.com/multiline-text-art/ on setting "Black 7")
    TEXT_SQUINGO = `
 â–„â–ˆâ–€â–€â–€â–„â–ˆ   â–„â–„â–ˆâ–€â–€â–ˆâ–ˆ   â–€â–ˆâ–ˆâ–€  â–€â–ˆâ–€ â–€â–ˆâ–ˆâ–€ â–€â–ˆâ–„   â–€â–ˆâ–€  â–„â–„â–ˆâ–€â–€â–€â–„â–ˆ   â–„â–„â–ˆâ–€â–€â–ˆâ–ˆ
 â–ˆâ–ˆâ–„â–„  â–€  â–„â–ˆâ–€    â–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆ   â–ˆâ–€â–ˆ   â–ˆ  â–„â–ˆâ–€     â–€  â–„â–ˆâ–€    â–ˆâ–ˆ
  â–€â–€â–ˆâ–ˆâ–ˆâ–„  â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆ   â–ˆ â–€â–ˆâ–„ â–ˆ  â–ˆâ–ˆ    â–„â–„â–„â–„ â–ˆâ–ˆ      â–ˆâ–ˆ
â–„     â–€â–ˆâ–ˆ â–€â–ˆâ–„  â–€â–„ â–€â–ˆ  â–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆ  â–€â–ˆâ–„    â–ˆâ–ˆ  â–€â–ˆâ–„     â–ˆâ–ˆ
â–ˆâ–€â–„â–„â–„â–„â–ˆâ–€    â–€â–ˆâ–„â–„â–„â–€â–ˆâ–„   â–€â–ˆâ–„â–„â–€   â–„â–ˆâ–ˆâ–„ â–„â–ˆâ–„   â–€â–ˆ   â–€â–€â–ˆâ–„â–„â–„â–€â–ˆ   â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€
`

    // text to print when the hand is a loss ("Not Squingo")
    // (text from https://texteditor.com/multiline-text-art/ on setting "Black 7")
    TEXT_NOT_SQUINGO = `
â–€â–ˆâ–„   â–€â–ˆâ–€  â–„â–„â–ˆâ–€â–€â–ˆâ–ˆ   â–ˆâ–€â–€â–ˆâ–ˆâ–€â–€â–ˆ     â–„â–ˆâ–€â–€â–€â–„â–ˆ   â–„â–„â–ˆâ–€â–€â–ˆâ–ˆ   â–€â–ˆâ–ˆâ–€  â–€â–ˆâ–€ â–€â–ˆâ–ˆâ–€ â–€â–ˆâ–„   â–€â–ˆâ–€  â–„â–„â–ˆâ–€â–€â–€â–„â–ˆ   â–„â–„â–ˆâ–€â–€â–ˆâ–ˆ
 â–ˆâ–€â–ˆ   â–ˆ  â–„â–ˆâ–€    â–ˆâ–ˆ     â–ˆâ–ˆ        â–ˆâ–ˆâ–„â–„  â–€  â–„â–ˆâ–€    â–ˆâ–ˆ   â–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆ   â–ˆâ–€â–ˆ   â–ˆ  â–„â–ˆâ–€     â–€  â–„â–ˆâ–€    â–ˆâ–ˆ
 â–ˆ â–€â–ˆâ–„ â–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ    â–ˆâ–ˆ         â–€â–€â–ˆâ–ˆâ–ˆâ–„  â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆ   â–ˆ â–€â–ˆâ–„ â–ˆ  â–ˆâ–ˆ    â–„â–„â–„â–„ â–ˆâ–ˆ      â–ˆâ–ˆ
 â–ˆ   â–ˆâ–ˆâ–ˆ  â–€â–ˆâ–„     â–ˆâ–ˆ    â–ˆâ–ˆ       â–„     â–€â–ˆâ–ˆ â–€â–ˆâ–„  â–€â–„ â–€â–ˆ  â–ˆâ–ˆ    â–ˆ   â–ˆâ–ˆ   â–ˆ   â–ˆâ–ˆâ–ˆ  â–€â–ˆâ–„    â–ˆâ–ˆ  â–€â–ˆâ–„     â–ˆâ–ˆ
â–„â–ˆâ–„   â–€â–ˆ   â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€    â–„â–ˆâ–ˆâ–„      â–ˆâ–€â–„â–„â–„â–„â–ˆâ–€    â–€â–ˆâ–„â–„â–„â–€â–ˆâ–„   â–€â–ˆâ–„â–„â–€   â–„â–ˆâ–ˆâ–„ â–„â–ˆâ–„   â–€â–ˆ   â–€â–€â–ˆâ–„â–„â–„â–€â–ˆ   â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€
`

    // text to print when the hand is a triple payout ("Monkey Pirate")
    // (text from https://texteditor.com/multiline-text-art/ on setting "Black 7")
    TEXT_MONKEY_PIRATE = `
â–€â–ˆâ–ˆ    â–ˆâ–ˆâ–€  â–„â–„â–ˆâ–€â–€â–ˆâ–ˆ   â–€â–ˆâ–„   â–€â–ˆâ–€ â–€â–ˆâ–ˆâ–€  â–ˆâ–€  â–€â–ˆâ–ˆâ–€â–€â–€â–€â–ˆ  â–€â–ˆâ–ˆâ–€ â–€â–ˆâ–€   â–€â–ˆâ–ˆâ–€â–€â–ˆâ–„  â–€â–ˆâ–ˆâ–€ â–€â–ˆâ–ˆâ–€â–€â–ˆâ–„       â–ˆ     â–ˆâ–€â–€â–ˆâ–ˆâ–€â–€â–ˆ â–€â–ˆâ–ˆâ–€â–€â–€â–€â–ˆ
 â–ˆâ–ˆâ–ˆ  â–ˆâ–ˆâ–ˆ  â–„â–ˆâ–€    â–ˆâ–ˆ   â–ˆâ–€â–ˆ   â–ˆ   â–ˆâ–ˆ â–„â–€     â–ˆâ–ˆ  â–„      â–ˆâ–ˆ â–ˆ      â–ˆâ–ˆ   â–ˆâ–ˆ  â–ˆâ–ˆ   â–ˆâ–ˆ   â–ˆâ–ˆ     â–ˆâ–ˆâ–ˆ       â–ˆâ–ˆ     â–ˆâ–ˆ  â–„
 â–ˆâ–€â–ˆâ–„â–„â–€â–ˆâ–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ  â–ˆ â–€â–ˆâ–„ â–ˆ   â–ˆâ–ˆâ–€â–ˆâ–„     â–ˆâ–ˆâ–€â–€â–ˆ       â–ˆâ–ˆ       â–ˆâ–ˆâ–„â–„â–„â–ˆâ–€  â–ˆâ–ˆ   â–ˆâ–ˆâ–€â–€â–ˆâ–€     â–ˆ  â–ˆâ–ˆ      â–ˆâ–ˆ     â–ˆâ–ˆâ–€â–€â–ˆ
 â–ˆ â–€â–ˆâ–€ â–ˆâ–ˆ  â–€â–ˆâ–„     â–ˆâ–ˆ  â–ˆ   â–ˆâ–ˆâ–ˆ   â–ˆâ–ˆ  â–ˆâ–ˆ    â–ˆâ–ˆ          â–ˆâ–ˆ       â–ˆâ–ˆ       â–ˆâ–ˆ   â–ˆâ–ˆ   â–ˆâ–„   â–„â–€â–€â–€â–€â–ˆâ–„     â–ˆâ–ˆ     â–ˆâ–ˆ
â–„â–ˆâ–„ â–ˆ â–„â–ˆâ–ˆâ–„  â–€â–€â–ˆâ–„â–„â–„â–ˆâ–€  â–„â–ˆâ–„   â–€â–ˆ  â–„â–ˆâ–ˆâ–„  â–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–„â–„â–„â–„â–„â–ˆ   â–„â–ˆâ–ˆâ–„     â–„â–ˆâ–ˆâ–„     â–„â–ˆâ–ˆâ–„ â–„â–ˆâ–ˆâ–„  â–€â–ˆâ–€ â–„â–ˆâ–„  â–„â–ˆâ–ˆâ–„   â–„â–ˆâ–ˆâ–„   â–„â–ˆâ–ˆâ–„â–„â–„â–„â–„â–ˆ
`

    // ASCII graphic to print when the hand is a triple payout ("Monkey Pirate")
    GRAPHIC_MONKEY_PIRATE = `
                                       .*,Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â %@%@@@@@@@@@@(Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â #&&@@@@@@@@@@@@@@#Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ./(#(//(&@&%&@@ %@@@@@@@@@@%(@@Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â @@%%%%%&@@@@@@@@(.&Â Â Â Â Â Â Â (@@. @@@@Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â @%%@@%@@@@@@@@@@@( .@* &@Â Â #@/&@@@@@@.Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .@@%@@@@@@@@@/ /.Â Â Â */Â Â Â Â @@@@@@@@@@&@@@@(Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â #%%@@@@@@@@@@@ @@# , .Â Â Â (Â Â (@@@@@@@@@@%%@@(Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â %%%%,,(@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@&%%&&Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â ,Â Â Â Â %%%,,,*%%%%%%%%%%%%@%%%%%%%&@@@@@@@@@@&(Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â ,,,Â Â Â Â Â &%&,%%%%%%%,,*,,&%%%%%%%%%%%%%%#,*,.&%%%Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â ,,,,Â Â Â Â Â Â Â Â /%%%%%,,,,/@*,,,%(,,,,,,%%%%%%,,,,%%%.Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â ,,,,,,Â Â Â Â Â Â Â (%%*,,,,&@/,,,,,,,,,,,,,,/%%%%(,#%%(,Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â ,,,,,,Â Â Â Â Â Â Â Â %%,,,@@@@*,,,,,,,,,,,,,,*%%%%//*Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â .,,,,,Â Â Â Â Â Â Â Â .#%@,,,*,,,***,,,,,*,,,,,(%%%Â Â Â Â Â Â ,*.Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â ,,,.*,Â Â Â Â Â Â Â Â Â (#,,,,,,(,,,,,,,,,,,,,,(%/Â Â Â %&%%,.#%%%#Â Â 
Â Â Â Â Â Â Â Â Â Â Â ,,,,,Â Â Â Â Â Â Â Â Â Â Â Â &*,,,,,,,**,,,,,,,#%,Â Â Â Â %%Â Â Â Â Â Â Â Â .%%Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â ,.,Â Â Â Â Â Â Â Â Â Â Â Â %####%#(*,,*/#%%#*Â Â Â Â Â Â Â Â %%%*Â Â Â Â Â Â /%&
Â Â Â Â Â Â Â Â Â Â Â Â Â ,((//,/%%%#%%%%#######*,,,##(####%%Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â (%%
Â Â Â Â Â Â Â Â Â Â Â Â Â Â ,,/(,%%%%%%%%######%#,,,,%//#####%%%%,Â Â Â Â Â Â Â Â Â Â Â ,%%Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ///Â Â Â Â Â Â (#####//##,,,,#%###%###%%%%/,,,Â Â Â Â Â Â #%%Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â *%###%%(%*,,,,(#%%#####%%(/,,,,,Â Â Â (%%.Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &%%*,,,,,,,,,,/####*Â Â Â Â Â .,*, (%#%Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â %%%%*,,,,,,/%%%%%#Â Â Â Â Â Â *#%%%(Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â #%%%%%%%%%%%%%#%%%%%%%%%%/Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &%%%%%%%%%%%%%%%%%%%Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â &%%%%%Â Â Â Â Â Â Â Â .%%%%%%,Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â /%%%%#Â Â Â Â Â Â Â Â Â Â /##*,,,Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â *,,,,,Â Â Â Â Â Â Â Â Â Â .,,,,,Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â 
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â .,,,,.

                HE DO BE TERRORIZING THE SEVEN SEAS THOUGH ðŸ‘€
`

    // relative paths to filler sound effects to play immediately after input is entered
    SFX_INPUT_PATHS = [
        "sfx/input/Robot_blip-Marianne_Gagnon-120342607.wav"
    ]

    // relative paths to beep sound effects to play when a processing a hand
    SFX_BEEP_PATHS = [
        "sfx/beep/Bleep-SoundBible.com-1927126940.wav"
    ]

    // relative paths to miscellanous filler sound effects to play when processing a hand
    SFX_MISC_PATHS = [
        "sfx/misc/Alien Brain Scanner-SoundBible.com-2034590144.wav",
        "sfx/misc/Computer Error Alert-SoundBible.com-783113881.wav",
        "sfx/misc/Martian_Death_Ray-Mike_Koenig-937891031.wav",
        "sfx/misc/Monster Growl-SoundBible.com-344645592.wav",
        "sfx/misc/Time Warp-SoundBible.com-634766493.wav",
        "sfx/misc/WilhelmScream.wav"
    ]

    // relative paths to sound effects to play when a hand is squingo
    SFX_SQUINGO_PATHS = [
        "sfx/squingo/cartoon-telephone_daniel_simion.wav",
        "sfx/squingo/Computer_Magic-Microsift-1901299923.wav",
        "sfx/squingo/Warning Siren-SoundBible.com-898272278.wav",
        "sfx/squingo/Zombie In Pain-SoundBible.com-134322253.wav",
    ]

    // relative paths to sound effects to play when a hand is not squingo
    SFX_NOT_SQUINGO_PATHS = [
        "sfx/not_squingo/Burp 2x-SoundBible.com-1895509911.wav",
        "sfx/not_squingo/Cat Scream-SoundBible.com-871191563.wav",
        "sfx/not_squingo/Laugh Evil-SoundBible.com-1059217446.wav",
        "sfx/not_squingo/Warning Siren-SoundBible.com-898272278.wav",
    ]

    // relative paths to sound effects to play when a hand is monkey pirate
    SFX_MONKEY_PIRATE_PATHS = [
        "sfx/monkey_pirate/monkey_pirate.wav"
    ]

    // the inclusive min amount of time in milliseconds to wait
    // between playing consecutive non-blocking sound effects
    INCLUSIVE_MIN_SFX_PAUSE_MS = 1000
    // the exclusive max amount of time in milliseconds to wait
    // between playing consecutive non-blocking sound effects
    EXCLUSIVE_MAX_SFX_PAUSE_MS = 3000

    /**
     * Return a random int in the half-open interval [inclusiveMin, exclusiveMax).
     */
    function randomIntInRange(inclusiveMin, exclusiveMax) {
        return inclusiveMin + Math.floor(Math.random() * (exclusiveMax - inclusiveMin));
    }

    function randomItemInArray(array) {
        return array[randomIntInRange(0, array.length)]
    }

    /**
     * Delay execution for the given duration.
     */
    function delay(durationMs) {
        return new Promise(resolve =>
            setTimeout(resolve, durationMs)
        )
    }

    /**
     * Play a random sound effect from the given list of sound effect paths,
     * blocking until the sound finishes.
     */
    function playRandomSfxFromPathsBlocking(sfxPaths) {
        const sfxPath = randomItemInArray(sfxPaths)
        return new Promise(resolve => {
            let audio = new Audio(sfxPath)
            audio.onended = resolve
            audio.play()
        })
    }

    /**
     * Without blocking, repeatedly wait a random amount of time
     * and then play a random sound from the given list of sound effect paths.
     * During each iteration, update the value in timeoutWrapper.timeout
     * with the current iteration's timeout, so that this function's original caller
     * can stop sounds from playing by calling cancelTimeout(timeoutWrapper.timeout).
     * (The caller created the timeoutWrapper object and then passed it by reference
     * into this function. Thus, the caller will see any edits that this function makes to
     * timeoutWrapper. If instead this function took a timeout primitive that wasn't contained
     * in a wrapper object, then this function would take the timeout by value, so the caller would
     * not see edits to the caller.)
     */
    function repeatRandomSfxFromPathsNonBlocking(sfxPaths, timeoutWrapper) {
        const delayTimeMs = randomIntInRange(INCLUSIVE_MIN_SFX_PAUSE_MS, EXCLUSIVE_MAX_SFX_PAUSE_MS)
        timeoutWrapper.timeout = setTimeout(() => {
            playRandomSfxFromPathsBlocking(sfxPaths)
            repeatRandomSfxFromPathsNonBlocking(sfxPaths, timeoutWrapper)
        }, delayTimeMs)
    }

    /**
     * Return the given input element's text when the user presses enter.
     */
    function getValueOnEnter(inputElement) {
        return new Promise(resolve => {
            inputElement.addEventListener("keydown", onKeyDown);

            function onKeyDown(e) {
                if (e.key === "Enter") {
                    inputElement.removeEventListener("keydown", onKeyDown);
                    resolve(inputElement.value);
                }
            }
        })
    }

    /**
     * Display an input element that prompts the user with the given text.
     */
    async function waitForInput(parentElement, promptText) {
        let promptElement = document.createElement("span")
        promptElement.classList.add("input-prompt")
        promptElement.appendChild(document.createTextNode(promptText))

        let inputElement = document.createElement("span")
        inputElement.setAttribute("contenteditable", "plaintext-only")
        inputElement.classList.add("input-so-far")

        let lineElement = document.createElement("div")
        lineElement.classList.add("input-line", "input-line-active")
        lineElement.append(promptElement, inputElement)

        parentElement.appendChild(lineElement)

        inputElement.focus()

        const input = await getValueOnEnter(inputElement)

        inputElement.blur()
        inputElement.classList.remove("input-line-active")

        return input
    }

    /**
     * Display a screen asking the user to enter a card hand.
     */
    async function runInputScreen(consoleElement) {
        let inputScreenElement = document.createElement("div")
        inputScreenElement.classList.add("input-screen")
        consoleElement.appendChild(inputScreenElement)

        const cardHand = await waitForInput(inputScreenElement, "Enter the card hand: ")
        await playRandomSfxFromPathsBlocking(SFX_INPUT_PATHS)

        return cardHand
    }

    /**
     * Display a bunch of junk characters.
     */
    async function runJunkScreen(consoleElement) {
        let junkScreenElement = document.createElement("div")
        junkScreenElement.classList.add("junk-screen")
        consoleElement.appendChild(junkScreenElement)

        let junkElement = document.createElement("span")
        junkScreenElement.appendChild(junkElement)

        const inclusiveMinNumCharsToPrint = randomIntInRange(10000, 15000)
        let numCharsPrinted = 0

        const junkChars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~ \t\t\t\t\t\t\t\n\r";

        while (numCharsPrinted < inclusiveMinNumCharsToPrint) {
            const numCharsInChunk = randomIntInRange(3, 2000)
            let chunkText = ""
            for (let indexInChunk = 0; indexInChunk < numCharsInChunk; ++indexInChunk) {
                const shouldPrintNonWhitespace = randomIntInRange(0, 3) == 0
                if (shouldPrintNonWhitespace) {
                    chunkText += randomItemInArray(junkChars)
                } else {
                    chunkText += '\xa0'
                }
            }

            let chunkElement = document.createElement("span")
            // const chunkColor = "#" + randomIntInRange(0, 256 ** 3).toString(16)
            // console.log(chunkColor)
            // chunkElement.style.color = chunkColor
            chunkElement.textContent += chunkText
            junkElement.appendChild(chunkElement)

            numCharsPrinted += numCharsInChunk
            const chunkDelayMs = (numCharsInChunk / 30) * randomIntInRange(1, 3)
            await delay(chunkDelayMs)
        }

        await delay(1000)
    }

    /**
     * Display a series of loading messages,
     * each made by combining a random verb and noun.
     */
    async function runLoadingMessages(loadingScreenElement) {
        let miscTimeoutWrapper = { timeout: null }
        repeatRandomSfxFromPathsNonBlocking(SFX_MISC_PATHS, miscTimeoutWrapper)
        await delay(1000)
        let beepTimeoutWrapper = { timeout: null }
        repeatRandomSfxFromPathsNonBlocking(SFX_BEEP_PATHS, beepTimeoutWrapper)

        const numLoadingMessages = randomIntInRange(4, 10)
        for (let loadingMessageIndex = 0; loadingMessageIndex <= numLoadingMessages; ++loadingMessageIndex) {
            let loadingMessageRowElement = document.createElement("div")
            loadingMessageRowElement.classList.add("active-loading-message")
            loadingScreenElement.appendChild(loadingMessageRowElement)

            if (Math.random() < LOADING_EASTER_EGG_PROBABILILITY) {
                loadingMessageRowElement.textContent = LOADING_EASTER_EGG_TEXT
            } else {
                const verb = randomItemInArray(LOADING_MESSAGE_VERBS)
                const noun = randomItemInArray(LOADING_MESSAGE_NOUNS)
                const textNoEllipsis = verb + ' ' + noun
                const textFrames = ELLIPSIS_FRAMES.map(ellipsisFrame => textNoEllipsis + ellipsisFrame)

                const numEllipses = randomIntInRange(1, 3)
                for (let ellipsisIndex = 0; ellipsisIndex < numEllipses; ++ellipsisIndex) {
                    for (const textFrame of textFrames) {
                        loadingMessageRowElement.textContent = textFrame
                        await delay(100)
                    }
                }

                loadingMessageRowElement.textContent += " done."
            }
            loadingMessageRowElement.classList.remove("active-loading-message")
            await delay(500)
        }

        clearTimeout(miscTimeoutWrapper.timeout)
        clearTimeout(beepTimeoutWrapper.timeout)
    }

    /**
     * Display a progress bar ranging from 0-100 that progresses randomly.
     * The bar freezes for a bit somewhere in the late 90th percentages.
     */
    async function runProgressBar(loadingScreenElement) {
        let postprocessingTextElement = document.createElement("div")
        postprocessingTextElement.classList.add("postprocessing-text")
        postprocessingTextElement.textContent = "Postprocessing..."
        loadingScreenElement.appendChild(postprocessingTextElement)

        let progressBarElement = document.createElement("div")
        progressBarElement.class = "progress-bar"
        loadingScreenElement.appendChild(progressBarElement)

        const freezePercentage = randomIntInRange(96, 100)

        for (let percentage = 0; percentage <= 100; ++percentage) {
            const currentProgressBarLengthChars = Math.round(FULL_PROGRESS_BAR_LENGTH_CHARS * percentage / 100)
            const progressBarText = '\u25A0'.repeat(currentProgressBarLengthChars) + '\xa0'.repeat(FULL_PROGRESS_BAR_LENGTH_CHARS - currentProgressBarLengthChars)
            progressBarElement.textContent = `${progressBarText}\xa0\xa0\xa0${percentage}%`

            const freezeTimeMs = percentage == freezePercentage
                ? PROGRESS_BAR_FREEZE_TIME_MS
                : randomIntInRange(5, 250)
            await delay(freezeTimeMs)
        }

        await delay(1000)
    }

    /**
     * Display the loading screen, which shows loading messages and a progress bar.
     */
    async function runLoadingScreen(consoleElement) {
        let loadingScreenElement = document.createElement("div")
        loadingScreenElement.classList.add("loading-screen")
        consoleElement.appendChild(loadingScreenElement)

        await runLoadingMessages(loadingScreenElement)
        await runProgressBar(loadingScreenElement)

        await delay(1000)
    }

    /**
     * return a key from the given map,
     * where each key's value is the relative probability of selecting that key
     */
    function selectOutcome(outcomeToRelativeProbability) {
        const denominator = Object.values(outcomeToRelativeProbability).reduce(
            (denominatorSoFar, relativeProbability) => denominatorSoFar + relativeProbability,
            0
        )

        const randomResult = randomIntInRange(0, denominator)
        let relativeProbabilityAlreadyChecked = 0

        // worked example of selecting a random number outcome:
        // * denominator = 46 + 44 + 10 = 100
        // * randomResult in [0, 100)
        // * probability 46/100 of randomResult falling in [0, 46),
        //   so probability 46/100 of (randomResult - 0) falling in [0, 46);
        // * probability 44/100 of randomResult falling in [46, 46 + 44),
        //   so probability 44/100 of (randomResult - 46) falling in [0, 44);
        // * probability 10/100 of randomResult falling in [46 + 44, 46 + 44 + 10),
        //   so probability 10/100 of (randomResult - 46 - 44) falling in [0, 10)

        for (const [outcome, relativeProbability] of Object.entries(outcomeToRelativeProbability)) {
            if (randomResult - relativeProbabilityAlreadyChecked < relativeProbability) {
                return outcome
            } else {
                relativeProbabilityAlreadyChecked += relativeProbability
            }
        }

        // the loop above should always terminate;
        // execution should never reach this point
        return Object.keys(outcomeToRelativeProbability)[0]
    }

    /**
     * Display a screen that shows the round's outcome.
     */
    async function runOutcomeScreen(consoleElement) {
        let outcomeElement = document.createElement("div")
        outcomeElement.classList.add("outcome-screen")
        consoleElement.appendChild(outcomeElement)

        let surveySaysTextElement = document.createElement("div")
        surveySaysTextElement.classList.add("survey-says-text")
        surveySaysTextElement.textContent = "Survey says..."
        outcomeElement.appendChild(surveySaysTextElement)

        await delay(1000)

        const outcome = selectOutcome(OUTCOME_TO_RELATIVE_PROBABILITY)

        switch (outcome) {
            case Outcome.SQUINGO:
                let squingoTextElement = document.createElement("div")
                squingoTextElement.classList.add("outcome-text", "outcome-text-squingo")
                squingoTextElement.textContent = TEXT_SQUINGO
                outcomeElement.appendChild(squingoTextElement)

                await playRandomSfxFromPathsBlocking(SFX_SQUINGO_PATHS)

                break;
            case Outcome.NOT_SQUINGO:
                let notSquingoTextElement = document.createElement("div")
                notSquingoTextElement.classList.add("outcome-text", "outcome-text-not-squingo")
                notSquingoTextElement.textContent = TEXT_NOT_SQUINGO
                outcomeElement.appendChild(notSquingoTextElement)

                await playRandomSfxFromPathsBlocking(SFX_NOT_SQUINGO_PATHS)

                break;
            default:  // monkey pirate
                let monkeyPirateTextElement = document.createElement("div")
                monkeyPirateTextElement.classList.add("outcome-text", "outcome-text-monkey-pirate")
                monkeyPirateTextElement.textContent = TEXT_MONKEY_PIRATE
                outcomeElement.appendChild(monkeyPirateTextElement)

                let monkeyPirateGraphicElement = document.createElement("div")
                monkeyPirateGraphicElement.classList.add("outcome-graphic", "outcome-graphic-monkey-pirate")
                monkeyPirateGraphicElement.textContent = GRAPHIC_MONKEY_PIRATE
                outcomeElement.appendChild(monkeyPirateGraphicElement)

                await playRandomSfxFromPathsBlocking(SFX_MONKEY_PIRATE_PATHS)

                break;
        }
    }

    /**
     * Run the game loop
     */
    async function runAllScreens() {
        document.title = randomItemInArray(PAGE_TITLES)

        const consoleElement = document.getElementById("console")

        while (true) {
            await runInputScreen(consoleElement)
            consoleElement.replaceChildren()

            await runJunkScreen(consoleElement)
            consoleElement.replaceChildren()

            await runLoadingScreen(consoleElement)
            consoleElement.replaceChildren()

            await runOutcomeScreen(consoleElement)
        }
    }

    runAllScreens()
</script>

</html>